import random
from typing import Optional
from ...Tool.asm_blocks import DataUnit
from ...Utils.configuration_management import Configuration, get_config_manager
from ...Utils.logger_management import get_logger
from ...Tool.state_management import get_state_manager
from ...Tool.memory_management.utils import convert_int_value_to_bytes

'''
#class MemoryBlock:
    Goal is to decouple Memory_block from memory operand, and allow requests of larger scope and at any side from memory requests that will be used as instructions operands
    usage example: request a 256b memory_block, and inside request 2 memory operands with overlapping offsets
    block = MemoryBlock(size_in_bits=256)
    mem1 = Memory(byte_size=8, , memory_block=block, memory_block_offset=0x0)
    mem1 = Memory(byte_size=8, , memory_block=block, memory_block_offset=0x7)

    assumption:
    - Every memory has a parent MemoryBlock, if non provided, a MemoryBlock at the memory size will be created.
    - block.name and block.byte_size are mandatory parameters.
    - Need to make sure Memory reside inside the block and not exceeds it 
    - When memory has a bigger block, it will use the block label + offset as reference 
    - The type and init-value are defined at the block level, a memory can't define a type or value when using a block (still we need this params when a memory is allocated without a MemoryBlock)
    - MemoryBlock can be at any size, unlike Memory which is limited to valid operand sizes of 8,16,32,64,128,256,512. (probably need some limitation not to exceed max offset size)
    - Big MemoryBlocks will be handled differently at the dataUnit asm generation to ensure linker allocation will be sequential  
    - Shared MemoryBlocks can be used randomly when Memory(shared=True) was asked.    
    - ??Question: MemorySegments will hold both Memories and MemoriesBlock? should Memory still maintain an individual label?  
    '''


class MemoryBlock:
    # generate incremental memory_unique_id
    _memory_block_initial_seed_id = random.randint(1234, 5678)  # start at a random label

    def __init__(
            self,
            byte_size: int,
            name: Optional[str] = None,
            address: Optional[int] = None,
            memory_type: Optional[str] = "WB",
            shared: bool = False,
            init_value: int = None,
            init_value_byte_representation: list[int] = None, # an optional to pass the init_value as a list of smaller bytes
            _use_name_as_unique_label: bool = False, # needed for cases the MemoryBlock was auto-generated by Memory without a block
    ):
        """
        Initializes a MemoryBlock with an address and a memory type

        Parameters:
        - name (str): The name of the memory block
        - address (int): The address of the memory block
        - type (str): The type of the memory block
        - shared (bool): decide if the memory should be shared or preserve, if shared other Memories can use it as their block
        """
        logger = get_logger()
        config_manager = get_config_manager()
        state_manager = get_state_manager()
        curr_state = state_manager.get_active_state()

        MemoryBlock._memory_block_initial_seed_id += 1
        self.name = name if name is not None else f"mem{MemoryBlock._memory_block_initial_seed_id}"
        if _use_name_as_unique_label:
            self.unique_label = self.name
        else:
            self.unique_label = self.name if name is None else f"{self.name}_mem{MemoryBlock._memory_block_initial_seed_id}"
        self.address = address
        self.byte_size = byte_size
        self.memory_type = memory_type
        self.shared = shared
        self.data_unit: DataUnit = None

        self.init_value_byte_representation = None
        if init_value is not None and init_value_byte_representation is not None:
            raise ValueError("Can't provide both 'init_value' and 'byte_representation', only one.")
        if shared and (init_value is not None or init_value_byte_representation is not None):
            # TODO:: is this limitation really needed? why not allow it the first time and force not to use a reused-memory ?
            raise ValueError(f"Can't initialize value in a shared memory")
        if init_value is not None:
            # Validate that init_value fits within the specified block size
            if init_value.bit_length() // 8 + 1 > self.byte_size:
                raise ValueError(f"init_value is too large for the specified block size ({self.byte_size} bytes).")
            # Convert the large init_value into smaller byte chunks, padding if necessary
            self.init_value_byte_representation = convert_int_value_to_bytes(init_value, self.byte_size)
        if init_value_byte_representation is not None:
            self.init_value_byte_representation = init_value_byte_representation

        if self.byte_size is None:
            raise ValueError("MemoryBlock.byte_size is a mandatory parameter.")



        execution_platform = config_manager.get_value('Execution_platform')
        if execution_platform == 'linked_elf' and address is not None:
            raise ValueError("Operating in linked ELF mode. Address setting is not available.")


        if shared:
            pool_type = Configuration.Memory_types.DATA_SHARED
        else:
            pool_type = Configuration.Memory_types.DATA_PRESERVE
        # allocate_data_memory will select a MemorySegment from a valid pool, and in 'baremetal' will select an available interval as start address
        self.data_unit = curr_state.memory_manager.allocate_data_memory(name=self.name,
                                                                        memory_block_id=self.unique_label,
                                                                        pool_type=pool_type, byte_size=byte_size,
                                                                        init_value_byte_representation=self.init_value_byte_representation)

        self.memory_segment_name = self.data_unit.memory_segment_id
        if execution_platform == 'baremetal':
            self.address = self.data_unit.address
            self.base_reg = curr_state.base_register
            self.base_reg_value = curr_state.base_register_value
            self.offset = self.address - curr_state.base_register_value
        else:
            self.address = None
            self.base_reg = None
            self.base_reg_value = None
            self.offset = None

        if self.init_value_byte_representation is not None:
            formatted_bytes = ", ".join(f"0x{byte:02x}" for byte in self.init_value_byte_representation)
        else:
            formatted_bytes = "None"

        self.memory_block_str = (f"[MemoryBlock: name={self.name}, "
                                 f"mem_segment={self.memory_segment_name}, "
                                 f"unique_label={self.unique_label}, "
                                 f"shared={self.shared}, "
                                 f"bytesize={self.byte_size}, "
                                 f"memory_type={self.memory_type}, "
                                 f"init_value:{formatted_bytes}]")


        logger.debug(self.memory_block_str)
        # print(self.memory_block_str)

        # add self to the memory_segment's memory_block_list
        memory_segment = curr_state.memory_manager.get_segment(self.memory_segment_name)
        memory_segment.memory_block_list.append(self)

    def __str__(self):
        return self.memory_block_str
