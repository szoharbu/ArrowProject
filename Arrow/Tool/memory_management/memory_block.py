import random
from typing import Optional
from Arrow.Tool.asm_blocks import DataUnit
from Arrow.Utils.configuration_management import Configuration, get_config_manager
from Arrow.Utils.logger_management import get_logger
from Arrow.Tool.state_management import get_state_manager, get_current_state
from Arrow.Tool.memory_management.utils import convert_int_value_to_bytes
from Arrow.Tool.memory_management.memory_logger import get_memory_logger
#from Arrow.Tool.memory_management.memlayout.page_table_manager import get_page_table_manager
'''
#class MemoryBlock:
    Goal is to decouple Memory_block from memory operand, and allow requests of larger scope and at any side from memory requests that will be used as instructions operands
    usage example: request a 256b memory_block, and inside request 2 memory operands with overlapping offsets
    block = MemoryBlock(size_in_bits=256)
    mem1 = Memory(byte_size=8, , memory_block=block, memory_block_offset=0x0)
    mem1 = Memory(byte_size=8, , memory_block=block, memory_block_offset=0x7)

    assumption:
    - Every memory has a parent MemoryBlock, if non provided, a MemoryBlock at the memory size will be created.
    - block.name and block.byte_size are mandatory parameters.
    - Need to make sure Memory reside inside the block and not exceeds it 
    - When memory has a bigger block, it will use the block label + offset as reference 
    - The type and init-value are defined at the block level, a memory can't define a type or value when using a block (still we need this params when a memory is allocated without a MemoryBlock)
    - MemoryBlock can be at any size, unlike Memory which is limited to valid operand sizes of 8,16,32,64,128,256,512. (probably need some limitation not to exceed max offset size)
    - Big MemoryBlocks will be handled differently at the dataUnit asm generation to ensure linker allocation will be sequential  
    - Shared MemoryBlocks can be used randomly when Memory(shared=True) was asked.    
    - ??Question: MemorySegments will hold both Memories and MemoriesBlock? should Memory still maintain an individual label?  
    '''


class MemoryBlock:
    # generate incremental memory_unique_id
    _memory_block_initial_seed_id = random.randint(1234, 5678)  # start at a random label

    def __init__(
            self,
            byte_size: int,
            name: Optional[str] = None,
            address: Optional[int] = None,
            memory_type: Optional[str] = "WB",
            shared: bool = False,
            alignment: Optional[int] = None,
            init_value: int = None,
            init_value_byte_representation: list[int] = None, # an optional to pass the init_value as a list of smaller bytes
            cross_core: bool = False,
            _use_name_as_unique_label: bool = False, # needed for cases the MemoryBlock was auto-generated by Memory without a block
    ):
        """
        Initializes a MemoryBlock with an address and a memory type

        Parameters:
        - name (str): The name of the memory block
        - address (int): The address of the memory block
        - type (str): The type of the memory block
        - shared (bool): decide if the memory should be shared or preserve, if shared other Memories can use it as their block
        - alignment (int): The alignment of the memory block, default is 4
        - cross_core (bool): decide if the memory should be cross-core, if true it will be allocated from a cross-core page and segment
        """
        logger = get_logger()
        config_manager = get_config_manager()
        state_manager = get_state_manager()
        curr_state = state_manager.get_active_state()
        curr_page_table = curr_state.current_el_page_table

        MemoryBlock._memory_block_initial_seed_id += 1
        self.name = name if name is not None else f"mem{MemoryBlock._memory_block_initial_seed_id}"
        if _use_name_as_unique_label:
            self.unique_label = self.name
        else:
            self.unique_label = self.name if name is None else f"{self.name}_mem{MemoryBlock._memory_block_initial_seed_id}"
        self._address = address
        self.byte_size = byte_size
        self.memory_type = memory_type
        self.shared = shared
        self.alignment = alignment
        self.data_unit: DataUnit = None
        # self.init_value - not needed, converted to byte_representation
        # self.init_value_byte_representation - not needed, will be set later
        self.cross_core = cross_core

        # Validate input parameters
        both_values_provided = init_value is not None and init_value_byte_representation is not None
        if both_values_provided:
            raise ValueError("Can't provide both 'init_value' and 'byte_representation', only one.")

        # At this point, we know we don't have both values
        has_init = init_value is not None or init_value_byte_representation is not None
        if shared and has_init:
            raise ValueError(f"Can't initialize value in a shared memory")
        
        if cross_core and shared:
            raise ValueError(f"Cross-core memory blocks can't be shared")
        
        #NOTE:: All Data must to be initialized. in case of shared block we will randomly initialize the entire section.  

        # Process initialization value if provided
        if not has_init:
            if shared:
                self.init_value_byte_representation = None
            else:
                # Create a bytearray of specified size
                random_block = bytearray(byte_size)
                # Fill with random values
                for i in range(byte_size):
                    random_block[i] = random.randint(0, 255)
                self.init_value_byte_representation = random_block
        elif init_value is not None:
            # Validate that init_value fits within the specified block size
            if init_value == 0:
                required_bytes = 1
            else:
                required_bytes = (init_value.bit_length() + 7) // 8  # Round up to nearest byte
            
            if required_bytes > self.byte_size:
                raise ValueError(f"init_value is too large for the specified block size ({self.byte_size} bytes). Value requires {required_bytes} bytes.")
            # Convert the large init_value into smaller byte chunks, padding if necessary
            self.init_value_byte_representation = convert_int_value_to_bytes(init_value, self.byte_size)
        else:  # init_value_byte_representation is not None
            self.init_value_byte_representation = init_value_byte_representation

        if self.byte_size is None:
            raise ValueError("MemoryBlock.byte_size is a mandatory parameter.")


        execution_platform = config_manager.get_value('Execution_platform')
        if execution_platform == 'linked_elf' and address is not None:
            raise ValueError("Operating in linked ELF mode. Address setting is not available.")


        if shared:
            pool_type = Configuration.Memory_types.DATA_SHARED
        else:
            pool_type = Configuration.Memory_types.DATA_PRESERVE
        # allocate_data_memory will select a MemorySegment from a valid pool, and in 'baremetal' will select an available interval as start address
        # return a dict of state_name: data_unit, as in case of cross-core memory, the allocate_data_memory will allocate data_unit for all states.

        from Arrow.Tool.memory_management.memory_usage import allocate_data_memory
        per_page_table_data_units = allocate_data_memory(segment_manager=curr_page_table.segment_manager,
                                                    name=self.name,
                                                    memory_block_id=self.unique_label,
                                                    pool_type=pool_type, byte_size=byte_size,
                                                    init_value_byte_representation=self.init_value_byte_representation,
                                                    alignment=self.alignment,
                                                    cross_core=self.cross_core)

        self.data_unit = per_page_table_data_units[curr_page_table.page_table_name]
        self.memory_segment_name = self.data_unit.memory_segment_id
        self.memory_segment = curr_page_table.segment_manager.get_segment(self.memory_segment_name)

        if execution_platform == 'baremetal':
            self._address = self.data_unit.address
            self.offset_from_segment_start = self._address - self.memory_segment.address
            self._pa_address = self.memory_segment.pa_address + self.offset_from_segment_start
            if Configuration.Architecture.x86:
                self.base_reg = curr_state.base_register
                self.base_reg_value = curr_state.base_register_value
                self.offset = self._address - curr_state.base_register_value
            else:
                self.offset = None
        else:
            self._address = None
            self.offset_from_segment_start = None
            self._pa_address = None
            self.base_reg = None
            self.base_reg_value = None
            self.offset = None

        if self.init_value_byte_representation is not None:
            formatted_bytes = ", ".join(f"0x{byte:02x}" for byte in self.init_value_byte_representation)
        else:
            formatted_bytes = "None"

        self.memory_block_str = (f"[MemoryBlock {curr_state.state_name}: name={self.name}, "
                                 f"memory_segment_name={self.memory_segment_name}, "
                                 f"address={hex(self._address)}, "
                                 f"pa_address={hex(self._pa_address)}, "
                                 f"unique_label={self.unique_label}, "
                                 f"shared={self.shared}, "
                                 f"bytesize={self.byte_size}, "
                                 f"memory_type={self.memory_type}, "
                                 f"alignment={self.alignment}, "
                                 f"init_value:{formatted_bytes}, "
                                 f"cross_core={self.cross_core}]")

        memory_logger = get_memory_logger()
        memory_logger.info("")
        memory_logger.info(f" MemoryBlock created: {self.memory_block_str}")
        # print(self.memory_block_str)

        # add self to the memory_segment's memory_block_list
        self.memory_segment.memory_block_list.append(self)

        # creating cross-core "shallow" copies for all states.
        per_page_table_cross_core_blocks = {curr_page_table.page_table_name: self}

        if cross_core:
            from Arrow.Tool.memory_management.memlayout.page_table_manager import get_page_table_manager

            for page_table_name, data_unit in per_page_table_data_units.items():
                if page_table_name != curr_page_table.page_table_name:
                    page_table_manager = get_page_table_manager()
                    page_table = page_table_manager.get_page_table(page_table_name)
                    # Create a cross-core copy
                    copy_block = MemoryBlock.create_cross_core_copy(self, page_table, data_unit)
                    per_page_table_cross_core_blocks[page_table_name] = copy_block


        self.cross_page_table_blocks = per_page_table_cross_core_blocks
        
        # map the cross_core_blocks across all blocks
        for page_table_name, copied_block in per_page_table_cross_core_blocks.items():
            copied_block.cross_page_table_blocks = per_page_table_cross_core_blocks


    def __str__(self):
        if self.cross_core:
            curr_state = get_current_state()
            curr_page_table = curr_state.current_el_page_table
            return self.cross_page_table_blocks[curr_page_table.page_table_name].memory_block_str
        else:
            return self.memory_block_str


    def get_address(self):
        if self.cross_core:
            curr_state = get_current_state()
            curr_page_table = curr_state.current_el_page_table
            return self.cross_page_table_blocks[curr_page_table.page_table_name]._address
        else:
            return self._address

    def get_pa_address(self):
        return self._pa_address

    def get_label(self):
        if self.cross_core:
            curr_state = get_current_state()
            curr_page_table = curr_state.current_el_page_table
            return self.cross_page_table_blocks[curr_page_table.page_table_name].unique_label
        else:
            return self.unique_label

    @classmethod
    def create_cross_core_copy(cls, original_block, page_table, data_unit):
        """Create a shallow copy of a memory block for cross-core use"""
        copy = cls.__new__(cls)  # Create instance without calling __init__
        
        # Copy attributes from original
        copy.name = f"{original_block.name}__{page_table.page_table_name}"
        copy.unique_label = f"{original_block.unique_label}__{page_table.page_table_name}"
        copy.byte_size = original_block.byte_size
        copy.memory_type = original_block.memory_type
        copy.shared = False  # Copies can't be shared
        copy.alignment = original_block.alignment
        copy.cross_core = True
        
        # Set the data unit
        copy.data_unit = data_unit
        
        tmp_state = get_current_state()

        # Set up remaining properties based on the data unit
        copy.memory_segment_name = data_unit.memory_segment_id
        copy.memory_segment = page_table.segment_manager.get_segment(copy.memory_segment_name)
        
        # Set up memory addresses based on execution platform
        copy._address = data_unit.address
        copy.offset_from_segment_start = copy._address - copy.memory_segment.address
        copy._pa_address = copy.memory_segment.pa_address + copy.offset_from_segment_start
        
        # Generate the string representation
        copy.memory_block_str = (f"[MemoryBlock {page_table.page_table_name}: name={copy.name}, "
                                f"memory_segment_name={copy.memory_segment_name}, "
                                f"address={hex(copy._address) if copy._address else 'None'}, "
                                f"pa_address={hex(copy._pa_address) if copy._pa_address else 'None'}, "
                                f"unique_label={copy.unique_label}, "
                                f"shared={copy.shared}, "
                                f"bytesize={copy.byte_size}, "
                                f"memory_type={copy.memory_type}, "
                                f"alignment={copy.alignment}, "
                                f"cross_core={copy.cross_core}, "
                                f"cross_core_original={original_block.name}]")
        
        # Log the new block
        memory_logger = get_memory_logger()
        memory_logger.info(f" MemoryBlock copy created: {copy.memory_block_str}")
        
        # Add to memory segment
        copy.memory_segment.memory_block_list.append(copy)
        
        return copy
